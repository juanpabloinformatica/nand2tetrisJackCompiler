#include "CompilationEngine.hpp"

inline std::string CompilationEngine::tokenListKey() {
  return this->tokenList.at(this->tokenListIndex)->begin()->first;
}
inline JackTypes::TokenType CompilationEngine::tokenListValue() {
  return this->tokenList.at(this->tokenListIndex)->begin()->second;
}
/*With this I will be able to re-use the token-list generated by the tokenizer*/
/*I don't really get the whole process I think that the advance and stuff is to
 * move get token*/
/*and then let the compilation takes cares, nevertheless I will continue this
 * way then I will see*/
CompilationEngine::CompilationEngine(
    const std::vector<std::map<std::string, JackTypes::TokenType> *> &tokenList)
#ifdef DEBUG
    /*:outputFile(std::string("./test/output_test_1.xml")),*/  /*test_1*/
    /*: outputFile(std::string("./test/output_test_2.xml")),*/ /*test_2*/
    /*: outputFile(std::string("./test/output_test_3.xml")),*/ /*test_3*/
    /*: outputFile(std::string("./test/output_test_4.xml")),*/ /*test_4*/
    : outputFile(std::string("./test/output_test_5.xml")),     /*test_5*/
#else
    : outputFile(std::string("./test/output_compilation.xml")),
#endif

      tokenList(tokenList),
#ifdef DEBUG
      /*tokenListIndex(tokenList.size() - 6)*/ /*For test_1*/
      /*tokenListIndex(tokenList.size() - 6)*/ /*For test_2*/
      /*tokenListIndex(tokenList.size() - 1)*/ /*For test_3*/
      /*tokenListIndex(tokenList.size() - 1)*/ /*For test_4*/
      tokenListIndex(tokenList.size() - 4)     /*For test_5*/

#else
      tokenListIndex(0),
#endif
      flagIsDoStatement(false) {
}

void CompilationEngine::run() {
  this->outputFile << "<tokens>" << "\n";
  this->compileClass();
  this->outputFile << "</tokens>";
}
void CompilationEngine::writeToFile() {
  JackTypes::TokenType tokenType = this->tokenListValue();
  const std::string &token = this->tokenListKey();

  /*identation*/
  this->outputFile << "\t";
  switch (tokenType) {
  case JackTypes::KEYWORD:
    this->outputFile << "<keyword> " << token << " </keyword>" << "\n";
    break;
  case JackTypes::SYMBOL: {
    std::string symbol = token;
    if (token == "<")
      symbol = "&lt;";
    if (token == ">")
      symbol = "&gt;";
    if (token == "\"")
      symbol = "quot;";
    if (token == "&")
      symbol = "&amp;";

    this->outputFile << "<symbol> " << symbol << " </symbol>" << "\n";
  } break;
  case JackTypes::IDENTIFIER:
    this->outputFile << "<identifier> " << token << " </identifier>"
                     << "\n";
    break;
  case JackTypes::INT_CONST:
    this->outputFile << "<integerConstant> " << token << " </integerConstant>"
                     << "\n";
    break;
  case JackTypes::STRING_CONST:
    this->outputFile << "<stringConstant> " << token << " </stringConstant>"
                     << "\n";
    break;
  default:
    break;
  }
}
void CompilationEngine::compileClass() {
  if (!(this->tokenListKey() == "class"))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListValue() == JackTypes::IDENTIFIER))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListKey() == "{"))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  this->compileClassVarDec();
}
void CompilationEngine::compileClassVarDec() {
  if (!(this->tokenListKey() == "static" || this->tokenListKey() == "field"))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListKey() == "int" || this->tokenListKey() == "char" ||
        this->tokenListKey() == "boolean" ||
        this->tokenListValue() == JackTypes::IDENTIFIER))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListValue() == JackTypes::IDENTIFIER))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  while ((this->tokenListKey() == ",") &&
         (this->tokenListValue() == JackTypes::IDENTIFIER)) {
    this->writeToFile();
    this->tokenListIndex++;
    this->writeToFile();
    this->tokenListIndex++;
  }
  if (!(this->tokenListKey() == ";"))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  return;
}
void CompilationEngine::compileSubroutine() {
  if (!(this->tokenListKey() == "constructor" ||
        this->tokenListKey() == "function" || this->tokenListKey() == "method"))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListKey() == "void" || this->tokenListKey() == "int" ||
        this->tokenListKey() == "char" || this->tokenListKey() == "boolean" ||
        this->tokenListValue() == JackTypes::IDENTIFIER))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListValue() == JackTypes::IDENTIFIER))
    return;
  this->writeToFile();
  this->tokenListIndex++;
  if (!(this->tokenListKey() == "("))
    return;
  this->writeToFile();
  this->tokenListIndex++;

  this->compileParameterList();

  if (!(this->tokenListKey() == ")"))
    return;
  this->writeToFile();
  this->tokenListIndex++;

	// this->compileSubroutine
}

const std::vector<std::map<std::string, JackTypes::TokenType> *> &
CompilationEngine::getTokenList() {
  return this->tokenList;
}
CompilationEngine::~CompilationEngine() {
  std::cout << "Calling compilation engine destructor" << "\n";
}
